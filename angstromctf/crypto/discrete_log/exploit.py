# We define a^^b to be such that a^^0 = 1 and a^^b = a^(a^^(b-1)), where x^y represents x to the power of y.
# Given this, find a positive integer x such that a^^x = b mod p.
'''Property 1:
(m * n) % p has a very interesting property:
(m * n) % p =((m % p) * (n % p)) % p

Property 2:'''
import time
import math
from pwn import *
'''def power(a, b, c):
    if b % 2 == 0:
        return ((pow(a, b/2) * pow(a, b/2)) % c)
    else:
        return (a * (pow(a, b - 1)) % c)'''

import itertools


def tetration(a, b):
    if b != 0:
        return(a ** tetration(a, b-1))
    else:
        return 1
def phi(x):
    'Cumulative distribution function for the standard normal distribution'
    return (1.0 + math.erf(x / math.sqrt(2.0))) / 2.0
'''a^k mod m = a^(k+phi(m)) mod m as long as k>log_2 m.
a^T(a,b-1) mod m = a^(T(a,b-1) mod phi(m) [minimum [log_2 m]])'''
def tetration_mod_m(a, b, m):
    if b != 0:
        return (a^(tetration(a, b-1)) % (int(phi(m)) * int(math.log2(m))))
    else:
        return 1
def solver(p, a, b):
    found = False
    x = 0
    b_mod_p = b % p
    current = tetration_mod_m(a, x, p)
    while not found:
        if current != b_mod_p:
            x += 1
            current = tetration_mod_m(a, x, p)
        else:
            found = True
    return x
r = remote('3.228.7.55', 20603)
for xyz in range(3):
    print(r.recvline())
for i in range(10):
    numbers = []
    for xyz in range(3):
        numbers.append(int(r.recvline().decode('utf-8').strip().split(' ')[2]))
    print(numbers)
    x = solver(numbers[0], numbers[1], numbers[2])
print(r.recvline())
input()