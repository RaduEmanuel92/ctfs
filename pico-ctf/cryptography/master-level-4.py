# revealing dp leaks enough information to find p
# e * d = 1 mod (p-1)(q-1)
# dp = d mod (p-1)
# so, h = e * dp - 1 = k * (p-1),  where k is small (because e is small)
# trying values for k gives us candidates for p, check n % p to find the real p

e = 65537
n = 248501410365662412791489552646042256782092770118253438700194718631291036762726489658495565276550205113648626040596191969135846656414394584577305526761671104277390765264806022908497647300596494542202565022133435383403344333672279722534625284520459706609569974491538689429548817677759350947931780871046796607829
dp = 13026685992320376966900872608865420374627539408788613307094830638345728123427345410810495082016593339528583880478309351125854158459979947140005048595481921

c = 194048013822218245260658018019940874060627700835842604475987702337533801266490182061968998210807564778328557627772974110046885380635225974269865976518335375789734689098164529086561756412074742698644530189076800227300946408167039318949544794351233987752575608106800908043533012088081995031010618521695843625062

h = e * dp - 1

k = 2
while k < h:
	if h % k == 0:
		p_candidate = h / k + 1
		print 'trying %s' % k
		if p_candidate < n and n % p_candidate == 0:
			print "found p: %s" % p_candidate
			p = p_candidate
			break
	k += 1

q = n / p
fi = (p-1) * (q-1)

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

d = modinv(e, fi)

m = pow(c, d, n)
#print hex(m)

message = str(hex(m))
message = message[2:-1].decode('hex')
print message
