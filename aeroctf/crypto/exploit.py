#/usr/bin/python3

from pwn import *
from Crypto.Cipher import AES
import base64
import sys
import string
from time import sleep
context.log_level = 'error'

# can get the flag, encrypted with the unknown 16bit svr key
# can get the encrypted flag, with different salts
# can decrypt any message using a client key
# can encrypt any message using a client key
# message and key will be 16bit length always
# everything is padded with "\x00"
# if the key is not 16bit length, is is padded like above


def pad( data ):
	return data + '\x00' * ( 16 - ( len( data ) % 16 ) )


def extract_b64s(encr_data):
    return str(encr_data).split(":")[1].split('\n')[0].split('\'')[1]


def encrypt( msg, key ):
	key = check_key( key ).encode()
	aes = AES.new( key, AES.MODE_ECB )
	return base64.b64encode( aes.encrypt( pad( msg ).encode() ) )


def decrypt( msg, key ):
	key = check_key( key ).encode()
	aes = AES.new( key, AES.MODE_ECB )
	return aes.decrypt( msg )


def get_data(conn, token):
    return conn.recvuntil(token, timeout=2, drop=True)


def svr_encrypt(conn, key, plain):
    conn.send("1\n")
    get_data(conn,"key:")
    conn.send("{}\n".format(key))
    get_data(conn, "data:")
    conn.send("{}\n".format(plain))
    blob = get_data(conn, ">")
    encr = extract_b64s(blob)
    return encr


def svr_decrypt(conn, key, encr_data):
    conn.send("2\n")
    get_data(conn,"key:")
    conn.send("{}\n".format(key))
    get_data(conn, "base64):")
    conn.send("{}\n".format(encr_data))
    blob = get_data(conn, ">")
    decr_data = extract_b64s(blob)
    return decr_data


def svr_get_secret(conn, salt):
    try:
        conn.send("3\n")
        get_data(conn, "salt: ")
        conn.send("{}\n".format(salt))
        encr_data = get_data(conn, ">")
        encr_flag = extract_b64s(encr_data)
        return base64.b64decode(encr_flag)

    except EOFError as e:
        print("reconnect:")
        sleep(0.3)
        conn = remote("tasks.aeroctf.com", 44323)
        get_data(conn, ">")
        return svr_get_secret(conn, salt)
    

def main():
    # Begin attack
    # Aero{5013ax}

    conn = remote("tasks.aeroctf.com", 44323)
    get_data(conn, ">")
    #encr_data = svr_encrypt(conn, "A", "A")
    #print(encr_data)
    #decr = svr_decrypt(conn, "A", encr_data)
    #print(decr)

    #1. get encr_flag
    #encr_flag = svr_get_secret(conn, "")
    

    one_fewer = svr_get_secret(conn, "B"*14) 
    print(one_fewer[0:16])
    
    blob = "B" * 14 + "Ae"
    encr_data = svr_get_secret(conn, blob)
    print("{} -> {}".format('A', encr_data[0:16]))

    padding = 16
    #Aero{5013a76ed3b98bae1e79169b3495f47a}
    flag  = 'Aero{5013a76ed3b'
    #             5013a76ed3b98bae1
    flag2 = '98bae1e79169b349'
    print(len(flag))
    
    flag3 = '5f4'
    padding = padding - len(flag3)

    possible_chars = string.ascii_lowercase + string.digits + "{}"
    idx = len(flag3)
    while(padding > 0):
        for cand_byte in possible_chars:
            blob_guess = "X" * (padding - 1) + flag + flag2 + flag3 + cand_byte
            #print(len(blob_guess))

            blob_flag  = "X" * (padding - 1) 
            #print (len(blob_flag))

            encr_guess     = svr_get_secret(conn, blob_guess)[32:48-idx]
            encr_flag_byte = svr_get_secret(conn, blob_flag)[32:48-idx]
            #print(encr_guess)
            #print(encr_flag_byte)
            if encr_guess == encr_flag_byte:
                flag3 += cand_byte
                print("Found : {}".format(flag3))
                padding -= 1
                idx += 1
                break


if __name__ == "__main__":
    main()